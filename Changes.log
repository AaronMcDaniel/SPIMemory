--> Added the ability to set page overflow - set to overflow by default
--> Added page turn feature - checks for overflow and increments page number
--> Added a function to empty an array before it is filled again - used by the writeAnything function
--> Added templates to read and write anything
--> Added a method to calculate length of any array to enable writing any array type to memory
--> Added a function to read and write any array (Optimized to read continuously instead of repeatedly calling the readByte function)
--> Add note to say that Page numbers go from 0-4095 and offset values from 0-255
--> Checks to see if data being written is the same as data already at the location. If so, does not overwrite - this reduces wear
--> Added the ability to read and write data to a particular location in the memory without a process that involves reading and writing the whole page - reduces wear
--> Enabled error check on all write commands to check for write errors
--> Added functions to write an array of bytes
--> Erase functions defined better and now work with page numbers instead of addresses.
--> Can now read/write continuously to/from an array of bytes
--> Now uniformly takes page_number & offset or page_number alone as arguments to find a location on the flash chip. Eliminates the need to remember byte addresses.

/*
template <class T> uint16_t _readAnything(uint16_t page_number, uint8_t offset, T& value)
{
    byte* p = (byte*)(void*)&value;
    uint16_t i;
    for (i = 0; i < sizeof(value); i++) {
        *p++ = readByte(page_number, offset++);
        if (offset > 255) {
            page_number = pageTurn(page_number);
            offset =0;
        }
    }
    return i;
}
	         
// WARNING: You can only write to previously erased memory locations (see datasheet).
//      Use the eraseSector()/eraseBlock32K/eraseBlock64K commands to first clear memory (write 0xFFs)
template <class T> uint16_t _writeAnything(uint16_t page_number, uint8_t offset, const T& value)
{
    uint8_t data_buffer[256];
    _empty(data_buffer);
    const byte* p = (const byte*)(const void*)&value;
    uint16_t i;
    for (i = 0; i < sizeof(value); i++) {
    	data_buffer[offset++] = *p++;
    	if (offset > 255) {
    		writePage(page_number, data_buffer);
    		page_number = pageTurn(page_number);
    		offset =0;
    	}
    }
    return i;
}   

template <class T> uint16_t _readAnyArray(uint16_t page_number, uint8_t offset, T& value)
{
    int length = arrayLen(value);

    uint32_t address = _getAddress(page_number, offset);
    _beginRead(address);
    for (int j = 0; j < (length + 1); j++) {
    byte* p = (byte*)(void*)&value[j];
    uint16_t i;
    for (i = 0; i < sizeof(value[j]); i++) {
    	*p++ = _readNextByte();
    	if (offset > 255) {
    		page_number = pageTurn(page_number);
    		offset =0;
    	}
    }
      return i;
  }
  _endProcess();
} 

// WARNING: You can only write to previously erased memory locations (see datasheet).
//      Use the eraseSector()/eraseBlock32K/eraseBlock64K commands to first clear memory (write 0xFFs)
template <class T> uint16_t _writeAnyArray(uint16_t page_number, uint8_t offset, const T& value)
{
    int length = arrayLen(value);

    uint8_t data_buffer[256];
    _empty(data_buffer);
    for (int j = 0; j < (length + 1); j++) {
    const byte* p = (const byte*)(const void*)&value[j];
    uint16_t i;
    for (i = 0; i < sizeof(value[j]); i++) {
    	data_buffer[offset++] = *p++;
    	if (offset > 255) {
    		writePage(page_number, data_buffer);
    		page_number = pageTurn(page_number);
    		offset = 0;
    	}
    }
      return i;
      }
}
	         
*/ 